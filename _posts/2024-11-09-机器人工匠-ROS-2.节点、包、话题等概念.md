---
layout:     post
title:      ROS - 2.节点、包、话题等概念
subtitle:   机器人操作系统ROS快速入门教程
date:       2024-11-09
author:     Space
header-img: img/the-first.png
catalog:   true
tags:
    - ROS


---



# 机器人操作系统 ROS 

### 10. Node节点和Package包

**1. ROS编程入门**

- 完成环境搭建后，开始ROS编程学习。

**2. 节点（Node）**

- ROS中最基本的程序单元是节点（Node）。
- 节点类似于安卓系统中的APP，每个节点负责特定的功能。
- 节点功能多样，但代码结构遵循固定套路。

**3. 包（Package）**

- 节点的组织形式称为包（Package）。
- ROS采用模块化设计，强调功能的相互独立。
- 包是节点的容器，用于组织和管理节点。

![image-20241023201737247](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019871.png)

**4. 节点的功能与结构**

- 单个节点功能单一，复杂任务通常由多个节点合作完成。
- 掌握节点的基本结构有助于理解整个程序。

![image-20240925000439999](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019872.png)

**5. 包的安装与管理**

- ROS中不能单独安装节点，必须以包为单位进行安装。
- 使用`apt`或`catkin_make`等工具安装包。

![image-20240925000544232](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019873.png)

**6. 编程实践**

- 从最简单的节点程序入手，熟悉节点的基本结构。
- 逐步在结构中添加功能，最终实现复杂功能。

**7. ROS的编译工具**

- ROS使用`catkin`作为编译工具，引入了包的概念。

![image-20240925000707755](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019874.png)

**8. 包的理解**

- 可以将包理解为节点的集合，方便管理和安装。

**注意事项**

- 理解节点和包的关系，以及它们在ROS中的作用。
- 学习ROS编程时，关注节点的固定编程套路。

**结束语**

- 通过逐步学习和实践，可以掌握ROS节点的编程和包的管理。
- ROS的模块化设计使得复杂任务的实现变得可行。



### 11. 年轻人的第一个Node节点

**1. 创建ROS包**

- 包是ROS中节点的组织形式。

![image-20241023202036073](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019875.png)

- 使用`catkin_create_package`命令创建包：

  ![image-20241023202244866](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019876.png)

  ```
  catkin_create_package ssr_package rospy roscpp std_msgs
  ```

  ![image-20240926084937741](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019877.png)

- 包名`SSR_package`，依赖项：`roscpp`、`std_msgs`。

- 改变vs code页面字体大小（也可以只改变代码部分字体大小）

![image-20240926085745914](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019878.png)

**2. 包结构**

- 新建的包包含`include`、`src`目录和`CMakeLists.txt`、`package.xml`文件。

`CMakeLists.txt` 和 `package.xml` 是在开发软件项目时常用的两个配置文件，它们分别用于不同的构建系统和包管理。

1. **CMakeLists.txt**：

   - 这是 CMake 构建系统的配置文件。CMake 是一个跨平台的自动化构建系统，它使用一个名为 CMakeLists.txt 的文件来生成标准的构建文件（如 Unix 的 Makefile 或 Windows 的 Visual Studio 项目文件）。
   - 在 `CMakeLists.txt` 文件中，你可以定义项目的构建目标（如可执行文件、库文件等）、指定源代码文件、设置编译选项、添加依赖关系、定义安装规则等。
   - 这个文件通常包含一系列的命令，这些命令告诉 CMake 如何构建项目。例如，你可以使用 `add_executable()` 命令来创建一个可执行文件，使用 `target_link_libraries()` 来链接库，或者使用 `include_directories()` 来添加头文件搜索路径。

   ![image-20240926090002089](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019879.png)

   

2. **package.xml**：

   - 这是 ROS（Robot Operating System）包管理器的配置文件。ROS 是一个用于机器人应用开发的中间件，它提供了一套工具和库来帮助开发者创建复杂的机器人行为。
   - `package.xml` 文件定义了 ROS 包的元数据，包括包的名称、版本、维护者、许可证、依赖关系等。
   - 这个文件还可以用来生成构建配置文件，但它的主要作用是提供包的描述信息，以便 ROS 工具链能够识别和处理包。例如，ROS 的 `rosdep` 工具会使用 `package.xml` 文件来安装依赖项。

   ![image-20241023202641306](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019880.png)

简而言之，`CMakeLists.txt` 是用于配置 CMake 构建系统的文件，而 `package.xml` 是用于 ROS 包管理的文件。两者都是软件开发中用于自动化和标准化构建过程的重要工具。

**3. 编写节点代码**

![image-20240926090201961](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019881.png)

![image-20240926090227507](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019882.png)

![image-20240926090544748](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019883.png)

![image-20240926090726578](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019884.png)

![image-20240926090823899](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019885.png)

1. `/opt/ros/noetic/share`：
   - 这个路径是ROS的系统安装路径的一部分，其中`/opt`是Linux系统中用于存放第三方软件的标准目录。
   - `ros`目录下通常会有不同版本的ROS安装，例如`noetic`是ROS 1的Noetic Ninjemys版本。
   - `share`目录是Unix系统中用于存放共享数据的标准目录。在ROS的上下文中，`/opt/ros/noetic/share`目录包含了ROS环境的一些共享资源，比如配置文件、消息定义、服务定义、动作定义等。
   - 这个目录下的文件通常是只读的，它们是ROS系统的一部分，不是由用户的工作空间中的包所覆盖的。
2. `catkin_ws/src`：
   - 这是用户的工作空间（workspace）中的一个目录，`catkin_ws`是ROS中最常用的工作空间名称，但这个名称可以自定义。
   - `catkin`是ROS 1中用于构建和管理软件包的工具。一个`catkin`工作空间通常包含`src`（源代码）、`build`（构建目录）、`devel`（开发目录，包含编译后的可执行文件和环境设置脚本）等子目录。
   - `src`目录用于存放用户自己的ROS包的源代码，或者第三方ROS包的源代码（如果这些包不是通过ROS的包管理工具如`apt`或`rosdep`安装的）。
   - 用户可以在`src`目录下创建新的ROS包，或者克隆、下载其他开发者的ROS包源代码。

简而言之，`/opt/ros/noetic/share`是ROS系统安装的一部分，包含了ROS环境的共享资源，而`catkin_ws/src`是用户工作空间的一部分，用于存放用户自己的ROS包源代码。这两个路径在ROS的文件系统中扮演着不同的角色。

![image-20240926092515699](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019886.png)

**此处修改虚拟机内的代码，原内容如下：**

```
export ROS_MASTER_URI=http://192.168.0.100:11311 
#虚拟机自己的ip地址，为了让小车可以找到虚拟机发出的ROS数据
#虚拟机端运行命令ip a可以查看虚拟机的ip地址
export ROS_HOSTNAME=192.168.0.136 
#以上两者ip地址的前三段【192.168.0】要一样
#前三段的数字没有要求可以为其他【192.168.1】、【192.168.2】但是要求两者一样
```

在最后添加下面代码

[ROS-debug1 : 运行roscore时报错：Unable to contact my own server at... - 燕清扬 - 博客园 (cnblogs.com)](https://www.cnblogs.com/yanqingyang/p/9823527.html#:~:text=ROS-debug1)

```
export ROS_HOSTNAME=localhost
export ROS_MASTER_URI=http://localhost:11311
```

![image-20240926094702226](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019888.png)

在bashrc文件末尾添加下述代码

```
source /opt/ros/noetic/setup.bash
source ~/catkin_ws/devel/setup.bash
```

![image-20240926143650178](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019889.png)

`.bashrc` 文件是 Bash shell 的重要配置文件，用于设置环境变量、别名、函数、命令提示符等，它帮助用户定制自己的命令行环境，提高使用效率。

1. **`source /opt/ros/noetic/setup.bash`**：
   - 此命令用于加载 ROS Noetic 的环境设置。
   - `setup.bash` 文件包含了 ROS 的环境变量和路径设置，使得你可以在终端中使用 ROS 命令和工具。
2. **`source ~/catkin_ws/devel/setup.bash`**：
   - 这条命令用于加载你自己的 Catkin 工作空间（`catkin_ws`）的环境设置。
   - `setup.bash` 文件在你的工作空间编译后生成，并包含了你在该工作空间中构建的包的路径和环境变量。



**4. 节点代码示例**

```cpp
#include  <ros/ros.h>

int main(int argc, char* argv[])
{
    ros::init(argc, argv, "chao_node");
    printf("我的枪去而复返，你的生命有去无回!\n");
    return 0;
}
```

这段代码是一个使用ROS（Robot Operating System）的C++程序。下面是代码的逐行解释：

```c
#include <ros/ros.h>
```

这行代码包含了ROS的头文件`ros.h`，它提供了ROS核心功能的访问，比如初始化节点、创建发布者和订阅者等。

```c
int main(int argc, char* argv[])
```

这是程序的主函数，`argc`是命令行参数的数量，`argv`是一个字符串数组，包含了命令行参数。

```c
{
```

这是`main`函数的开始。

```c
    ros::init(argc, argv, "chao_node");
```

这行代码初始化了一个名为`chao_node`的ROS节点。`ros::init`函数是ROS程序中的第一个调用的函数，它告诉ROS程序的名称和命令行参数。

```c
    printf("我的枪去而复返，你的生命有去无回!\n");
```

这行代码使用`printf`函数在终端打印出中文字符串“我的枪去而复返，你的生命有去无回!”。这通常用于显示程序已经开始运行，并且是节点初始化后的第一个操作。

```c
    return 0;
```

这行代码表示程序正常退出，并返回状态码0，这通常表示程序没有错误地完成了它的任务。

总结来说，这段代码创建了一个名为`chao_node`的ROS节点，然后打印了一条消息，最后正常退出。这可能是一个简单的示例程序，用于演示如何使用ROS创建节点和打印消息。在实际的ROS程序中，节点通常会执行更复杂的任务，比如订阅话题、发布消息、处理数据等。

**解决代码误报错方法——删除下面文件**

![image-20241023203530672](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019890.png)



**5. 编译配置**

- 修改`CMakeLists.txt`，添加节点的编译规则。

找到build部分下面的这部分内容

![image-20241023203721121](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019891.png)

```cmake
# Declare a C++ executable
# With catkin, all packages are built within a single CMake context
# The recommended prefix ensures that target names across packages don't collide

add_executable(${PROJECT_NAME}_node src/ssr_pkg_node.cpp)
```

这段代码的解释如下：

1. `# Declare a C++ executable`：
   - 这是一个注释，说明接下来要声明一个C++可执行文件。
2. `# With catkin, all packages are built within a single CMake context`：
   - 这同样是一个注释，说明在使用catkin构建系统时，所有的包都是在同一个CMake上下文中构建的。
3. `# The recommended prefix ensures that target names across packages don't collide`：
   - 这也是一个注释，说明推荐使用前缀来确保不同包中的目标（如可执行文件、库等）名称不会发生冲突。
4. `add_executable(${PROJECT_NAME}_node src/ssr_pkg_node.cpp)`：
   - 这是一个CMake命令，用于添加一个可执行目标（executable target）。
   - `${PROJECT_NAME}_node`：这是可执行文件的名称，它由项目的名称（`PROJECT_NAME`变量）和字符串`_node`组成。这样可以确保不同项目的可执行文件名称不会冲突。
   - `src/ssr_pkg_node.cpp`：这是源代码文件的路径，它指定了用来构建可执行文件的C++源文件。

总的来说，这段代码是在`CMakeLists.txt`文件中声明一个C++可执行文件，这个可执行文件是由指定的源文件`src/ssr_pkg_node.cpp`编译而成的，并且它的名称是由项目的名称和一个固定的后缀`_node`组成的，以避免在构建过程中不同项目的目标名称发生冲突。

![image-20241023205721989](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019892.png)

```cmake
# Specify libraries to link a library or executable target against
target_link_libraries(${PROJECT_NAME}_node ${catkin_LIBRARIES})
```

这段代码的解释如下：

1. `# Specify libraries to link a library or executable target against`：
   - 这是一个注释，说明接下来的命令是用来指定链接到库或可执行目标的库。
2. `target_link_libraries`：
   - 这是一个CMake命令，用于将一个或多个库链接到一个目标（通常是可执行文件或库文件）。
3. `${PROJECT_NAME}_node`：
   - 这是你要链接库的可执行目标的名称。`${PROJECT_NAME}`是一个变量，它代表你的项目名称，`_node`是通常用来表示这是一个ROS节点的后缀。
4. `${catkin_LIBRARIES}`：
   - 这是一个变量，包含了你的项目所依赖的所有ROS包的库文件。当你使用`find_package(catkin REQUIRED COMPONENTS ...)`命令时，CMake会查找这些依赖的ROS包，并设置`catkin_LIBRARIES`变量，其中包含了这些包的库文件路径。

总的来说，这段代码的作用是告诉CMake在构建过程中，将`${PROJECT_NAME}_node`这个可执行文件与`${catkin_LIBRARIES}`中指定的所有ROS包的库文件链接起来。这样，当`${PROJECT_NAME}_node`运行时，它就可以使用这些库中定义的功能了。

这个命令通常出现在`CMakeLists.txt`文件的末尾，确保在所有的依赖关系和目标都已经定义之后，再进行链接操作。这样可以确保所有的依赖项都已经被正确地解析和配置。

![image-20240926192437669](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019893.png)

```cmake
# Declare a C++ executable named "chao_node"
add_executable(chao_node src/chao_node.cpp)

# Specify libraries to link a library or executable target against
target_link_libraries(chao_node ${catkin_LIBRARIES})
```

简单来说，这段代码做了两件事：

1. 创建一个名为`chao_node`的程序，它是由`src`文件夹下的`chao_node.cpp`文件编译来的。
2. 把这个程序和ROS的一些库文件链接起来，这样我们的程序就可以使用ROS的功能了。

这段代码的解释如下：

1. `add_executable(chao_node src/chao_node.cpp)`：

   - 这行代码是在告诉CMake，我们要创建一个可执行的程序，我们可以运行的程序，它的名字叫`chao_node`。
   - 这个程序是由一个叫做`chao_node.cpp`的C++源文件编译来的。这个文件在`src`这个文件夹里。

   - `add_executable`命令的第一个参数是可执行文件的名称，这里是`chao_node`。
   - 第二个参数是源代码文件的路径，这里是`src/chao_node.cpp`。

2. `target_link_libraries(chao_node ${catkin_LIBRARIES})`：

   - 这行代码是在告诉CMake，我们需要把一些库文件链接到我们刚才创建的`chao_node`程序上。
   - 这些库文件是ROS系统中的库，它们被存储在`${catkin_LIBRARIES}`这个变量里。这个变量包含了所有我们需要的ROS功能，比如通信、数据处理等。
   - 链接这些库文件后，我们的`chao_node`程序就可以使用ROS提供的功能了。
   - `target_link_libraries`命令的第一个参数是目标名称，这里是`chao_node`。
   - `${catkin_LIBRARIES}`是一个变量，包含了你的项目所依赖的所有ROS包的库文件。当你使用`find_package(catkin REQUIRED COMPONENTS ...)`命令时，CMake会查找这些依赖的ROS包，并设置`catkin_LIBRARIES`变量，其中包含了这些包的库文件路径。

总的来说，这段代码的作用是告诉CMake在构建过程中，首先声明一个名为`chao_node`的可执行文件，它由`src/chao_node.cpp`源代码文件编译而成。然后，将`${catkin_LIBRARIES}`中指定的所有ROS包的库文件链接到这个可执行文件。这样，当`chao_node`运行时，它就可以使用这些库中定义的功能了。

这个命令通常出现在`CMakeLists.txt`文件中，确保在所有的依赖关系和目标都已经定义之后，再进行链接操作。这样可以确保所有的依赖项都已经被正确地解析和配置。

**编译节点步骤**

1. 在visualstudio中，Ctrl+shift+B 编译节点 or  Ctrl+Alt+T，打开终端，

   ![image-20241023204604575](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019894.png)

   ![image-20241023204549952](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019895.png)

**运行节点步骤**

1.Ctrl+Alt+T，打开终端，输入roscore启动ros系统

![image-20241023204304932](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019896.png)

2. Ctrl+shift+o，分出新的终端

![image-20241023204800549](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019897.png)

![image-20241023204926804](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019898.png)

这段内容是关于在ROS（Robot Operating System）环境中运行ROS包中的节点的命令行操作。下面是对这些命令的解释：

1. `robot@WP:~$ rosrun ssr pkg chao node`

   - 这是一个命令行指令，用于运行名为`ssr pkg`的ROS包中的`chao`节点。
   - `rosrun`是ROS的一个工具，用于在不预先编译整个工作空间的情况下，直接运行某个包的可执行文件（节点）。
   - `ssr pkg`是ROS包的名称，`chao`是该包中定义的节点名称，`node`是节点的可执行文件名称。
   - 但是，命令执行后出现了错误信息：`[rospack] Error: package 'ssr pkg' not found`，这表示ROS环境中没有找到名为`ssr pkg`的包。

2. `robot@WP:~$ source ~/catkin_ws/devel/setup.bash`

   - 这个命令用于为当前shell会话设置环境变量，以便能够找到并使用`catkin_ws`工作空间中的ROS包和节点。
   - `source`命令用于执行指定文件中的命令，这里执行的是`setup.bash`脚本，该脚本位于`catkin_ws/devel`目录下。
   - 这个脚本通常包含了设置ROS环境变量的命令，如`ROS_PACKAGE_PATH`，这样ROS工具（如`rosrun`）就可以找到并使用工作空间中的包。

   在ROS（Robot Operating System）中，每个工作空间（workspace）都有一个特定的目录结构，通常包括`src`（源代码目录）、`build`（构建目录）、`devel`（开发目录）等。`catkin_ws`是你的工作空间的名称，它是一个文件夹，里面包含了你的ROS项目。

   `source` 是一个bash shell命令，用于在当前shell会话中执行一个脚本文件中的命令。当你在命令行中输入 `source some_script.sh` 时，它会读取 `some_script.sh` 文件中的所有命令，并在当前shell环境中执行它们。

   `~/catkin_ws/devel/setup.bash` 是一个脚本文件的路径，其中 `~` 表示当前用户的主目录（home directory）。这个脚本是由 `catkin_make` 命令在构建ROS工作空间时自动生成的，它的作用是设置环境变量，以便ROS工具（如 `rosrun`、`roslaunch` 等）能够正确地找到和使用你的工作空间中的包和节点。

   具体来说，`setup.bash` 脚本会做以下几件事情：

   1. **设置 `ROS_PACKAGE_PATH` 环境变量**：这个变量告诉ROS在哪里可以找到ROS包。通过添加你的工作空间的 `src` 目录到 `ROS_PACKAGE_PATH`，ROS就可以识别和使用你的自定义包。
   2. **设置其他ROS相关的环境变量**：例如，`ROS_MASTER_URI`、`ROS_IP` 等，这些变量用于配置ROS网络通信和节点发现。
   3. **添加ROS工具到 `PATH` 环境变量**：这样你就可以在任何目录下直接使用 `rosrun`、`roslaunch` 等ROS工具，而不需要指定它们的完整路径。
   4. **设置其他必要的环境变量**：例如，`PYTHONPATH` 用于告诉Python解释器在哪里可以找到ROS包中的Python模块。

   通过执行 `source ~/catkin_ws/devel/setup.bash` 命令，你实际上是在告诉shell："嘿，我有一个ROS工作空间，我想在当前的shell会话中使用它。请设置必要的环境变量，以便我可以运行我的ROS节点和使用ROS工具。" 这样，你就可以在当前shell会话中顺利地使用ROS了。

   **将source ~/catkin_ws/devel/setup.bash`命令写入.bashrc文件中**

   ![image-20241023205240462](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019899.png)

   ![image-20241023205338829](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019900.png)

3. `robot@WP:~$ rosrun ssr pkg chao node`

   - 这是再次尝试运行`ssr pkg`包中的`chao`节点的命令。
   - 在执行了`source ~/catkin_ws/devel/setup.bash`命令之后，当前shell会话的环境变量被更新，使得`rosrun`能够找到并运行`ssr pkg`包中的节点。

总结来说，这段内容描述了在ROS环境中，由于初始环境变量未设置正确导致无法找到ROS包，通过source命令设置环境变量后，再次尝试运行包中的节点的过程。

**6. 编译和运行**

- 使用`catkin_make`在工作空间中编译包。

- 运行节点：

  ```
  rosrun SSR_package sonar_node
  ```

**7. 环境设置**

- 确保工作空间环境变量正确设置。
- 可以将环境变量加载命令添加到`.bashrc`文件。

**8. 调试和错误处理**

- 遇到编译或运行错误时，仔细阅读错误信息。
- 常见问题包括未保存文件、依赖项缺失、语法错误等。

**注意事项**

- 确保所有文件正确保存后再编译。
- 理解`CMakeLists.txt`和`package.xml`的作用。

![image-20240926201932305](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019901.png)

- 节点的循环条件应使用`ros::ok()`以响应外部信号。



**总结（构建ROS节点文件）**

![image-20240927095006320](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019902.png)

![image-20240927100452278](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019903.png)

![image-20240927100507012](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019904.png)

1. **使用catkin_create_pkg创建一个软件包**

   - 这一步是在终端中执行命令来创建一个新的ROS软件包。

2. **在软件包的src文件夹下创建一个节点的cpp源码文件**

   - 这一步是创建一个C++源文件，比如命名为`chao_node.cpp`。源码文件是你编写节点逻辑的地方。

3. **在节点的源码文件中include包含ROS的头文件**

   - 源码中对应的部分是：

     ```cpp
     #include <ros/ros.h>
     ```

   - 这行代码包含了ROS的核心头文件，使得你可以使用ROS的功能。

4. **构建一个main函数，并在函数的开头执行ros::init()**

   - 源码中对应的部分是：

     ```cpp
     int main(int argc, char* argv[])
     {
         ros::init(argc, argv, "chao_node");
     ```

   - `ros::init()`初始化ROS节点，`"chao_node"`是这个节点的名称。

5. **构建while循环，循环条件为ros::ok()**

   - 源码中对应的部分是：

     ```cpp
     while（ros::ok()）
     ```

   - `ros::ok()`函数用于检查节点是否还在正常运行。如果节点没有被关闭，它会返回`true`，因此while循环会一直执行，直到节点被关闭。

   - 循环条件不能是ture，要不然无法响应外部信号

6. **在CMakeLists.txt中设置节点源码的编译规则**

   - 这一步是在软件包的`CMakeLists.txt`文件中添加编译指令，告诉编译系统如何编译你的节点。
   - `CMakeLists.txt`是CMake构建系统的配置文件，用于指定如何编译和链接软件包中的源码文件。你需要在其中添加规则，告诉CMake如何编译你的节点。

7. **编译运行**

   - 这一步是使用`catkin_make`命令在终端中编译整个工作空间，然后使用`rosrun <package_name> <node_name>`来运行节点。源码中没有直接体现这一步，但这是运行节点的命令。
   - 在完成以上步骤后，你需要编译你的软件包。在ROS的工作环境（通常是工作空间）中，使用`catkin_make`（或`catkin build`）命令来编译。编译成功后，使用`rosrun`命令来运行你的节点。

你的源码是一个简单的ROS节点实现，它在初始化后进入一个无限循环，并在循环中打印字符串。这个节点没有使用`ros::ok()`来检查节点的状态，也没有发布或订阅任何话题，但它展示了ROS节点的基本结构。





### 12. Topic话题与Message消息

节点不能脱离包独立工作，传感器的信息要发送给马达

![image-20240928211506599](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019905.png)

**1. 节点间通讯**

- ROS节点通过话题（Topic）和消息（Message）进行通讯。

**2. 话题（Topic）**

- 话题是节点间进行持续通讯的一种形式。
- 一个话题可以有多个发布者（Publisher）和订阅者（Subscriber）。
- 话题名称是建立通讯的关键。

**3. 消息（Message）**

- 消息是话题中传输的数据载体。
- 消息可以持续不断地发送，保证数据的实时性。
- 消息格式多样，满足不同的数据传输要求。

**4. 发布者（Publisher）与订阅者（Subscriber）**

- 发布者是消息的发送方。
- 订阅者是消息的接收方。
- 一个节点可以同时是多个话题的发布者和订阅者。

![image-20240928211650559](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019906.png)

- 话题Topic是节点间进行持续通讯的一种形式。
- 话题通讯的两个节点通过话题的名称建立起话题通讯连接，
- 话题中通讯的数据，叫做消息Message
- 消息Message通常会按照一定的频率持续不断的发送，以保证消息数据的实时性。
- 消息的发送方叫做话题的发布者Publisher。
- 消息的接收方叫做话题的订阅者Subsciber。

![image-20241023211025423](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019907.png)

IMU是惯性测量单元（Inertial Measurement Unit）的缩写，它是一种用于测量和报告一个物体的特定力、角速度以及在某些情况下，其相对于参考坐标系的位置的设备。IMU通常用于需要精确运动感测的场合，比如航空、航海、陆地导航、机器人技术、手机、游戏控制和运动追踪等。

IMU的核心组件通常包括：

1. **加速度计（Accelerometer）**：测量物体在特定方向上的加速度，可以确定物体的线性运动。

2. **陀螺仪（Gyroscope）**：测量物体围绕各轴的角速度，可以确定物体的旋转运动。

3. **磁力计（Magnetometer）**：测量地球磁场在物体所在位置的方向和强度，可以用来确定物体的朝向。

这些传感器的数据可以被用来计算物体的绝对或相对位置、速度和方向。IMU可以提供实时、连续的运动数据，但它们通常需要与其他传感器（如GPS）结合使用，以提供更准确的定位信息，因为IMU的数据会受到漂移的影响，尤其是在长时间运行时。

在机器人技术中，IMU可以用来帮助机器人理解其在空间中的姿态和运动，从而进行平衡、导航和路径规划。在智能手机和平板电脑中，IMU是实现屏幕旋转、游戏控制和运动感应等功能的关键组件。在航空领域，IMU是飞行控制系统的重要组成部分，用于提供飞机姿态和速度的实时数据。

![image-20241023211245102](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019908.png)

**一个话题多个发布者的情况：**

![image-20240928212122828](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019909.png)

**外延补充：**

1. 一个ROS节点网络中，可以同时存在多个话题。
2. 一个话题可以有多个发布者，也可以有多个订阅者。
3. 一个节点可以对多个话题进行订阅，也可以发布多个话题。
4. 不同的传感器消息通常会拥有各自独立话题名称，每个话题只有一个发布者。
5. 机器人速度指令话题通常会有多个发布者，但是同一时间只能有一个发言人。



**5. 消息类型（Message Types）**

- ROS提供标准消息包（standard messages）。
- 消息类型多样，包括基础类型和复杂类型。
- 复杂消息类型由基础类型嵌套组合而成。

![image-20240928212356543](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019910.png)

**6. 使用ROS Index查找消息类型**

![image-20241023211433818](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019911.png)

标准消息类型本身就是依赖项，可以在ROS Index查找消息类型

- ROS Index网站提供了标准消息类型的定义。
- 通过网站可以查看不同版本ROS的消息类型。

![image-20240928212553259](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019912.png)

**7. 消息类型的结构**

- 消息类型可以像结构体一样包含多个成员。
- 可以层层展开消息类型，了解其携带的数据类型和容量。

![image-20240928212625814](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019913.png)

**注意事项**

- 传感器节点通常发布自己独立话题的消息。
- 控制类节点可能订阅多个传感器话题，并发布控制指令话题。
- 消息类型应根据数据传输需求合理选择或自定义。



### 13. Publisher发布者的C++实现

![image-20241023220853128](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019914.png)

**1. 话题发布者概述**

- 话题发布者负责向话题发送消息。
- 通过发布消息，节点之间可以共享数据。

**2. 确定话题名称和消息类型**

- 在网站内确定：https://index.ros.org

![image-20240928213300776](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019915.png)

![image-20240928213332823](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019916.png)

![image-20240928213753935](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019917.png)

![image-20240929084628016](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019918.png)

- **std_msgs/String Message**：这是ROS中的标准消息类型之一，用于传递字符串数据。
- **File: std_msgs/String.msg**：这表示消息定义文件的名称是`String.msg`，位于`std_msgs`包中。
- **Raw Message Definition**：
  - `string data`：这是消息定义中的一个字段，表示消息中包含一个字符串类型的数据。在原始消息定义中，这个字段被定义为`string data`。
- **Compact Message Definition**：
  - `string data`：在紧凑消息定义中，这个字段同样被定义为`string data`。

![image-20240929085030652](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019919.png)





- 话题名称："快上车开黑群"（需使用合法字符，避免中文）。
- 消息类型：使用`std_msgs/String`，因为需要发送字符串数据。

**3. 编写发布者节点代码**

注意话题名称不能是中文，“快上车开黑群”需要改成英问，不然运行节点时会报错，下述内容为便于理解，暂不修改

![image-20241023221317072](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019920.png)

这段代码是一个小机器人程序，它在ROS（机器人操作系统）的环境中运行。这个程序的作用是不断地发送消息，就像在聊天群里发消息一样。

1. 程序一开始，它会告诉ROS系统，它是一个名为"chao_node"的节点。

2. 然后，它会在控制台打印一句很酷的话："我的枪去而复返，你的生命有去无回!"。

3. 接着，它创建了一个"发布者"，这个发布者负责在ROS中的一个话题（可以理解为聊天群）上发送消息。这个话题的名字叫"快上车开黑群"。

4. 在一个循环中，程序会不断地创建一个消息，消息的内容是"国服马超，带飞"，然后通过发布者发送这个消息。

5. 每发送一次消息，程序会等待0.1秒，然后再次发送消息。

   #include <ros/ros.h>
   #include <std_msgs/String.h>

   int main(int argc, char* argv[])
   {
       // 初始化ROS节点，节点名为"chao_node"
       ros::init(argc, argv, "chao_node");
       // 在控制台打印一条消息
       printf("我的枪去而复返，你的生命有去无回!\n");

       // 创建一个节点句柄
       ros::NodeHandle nh;
       // 创建一个Publisher，发布到"快上车开黑群"话题，消息类型为std_msgs::String，队列大小为10
       ros::Publisher pub = nh.advertise<std_msgs::String>("kuai_shang_che_kai_hei_qun", 10);
       
       // 设置循环频率为10Hz
       ros::Rate loop_rate(10);
       // 进入循环，直到ROS节点关闭
       while (ros::ok())
       {
           // 创建一个消息对象
           std_msgs::String msg;
           // 设置消息内容
           msg.data = "国服马超，带飞";
           // 发布消息
           pub.publish(msg);
           // 等待直到下一次循环开始，保持10Hz的频率
           loop_rate.sleep();
       }
       
       // 返回0，表示程序正常结束
       return 0;

   }

6. 包含头文件：

   - `#include <ros/ros.h>`：包含ROS的核心功能，允许程序使用ROS的节点和通信机制。
   - `#include <std_msgs/String.h>`：包含标准消息类型`std_msgs::String`，这是一个简单的字符串消息类型。

7. 主函数：

   - `int main(int argc, char* argv[])`：程序的入口点，接收命令行参数。

8. 初始化ROS节点：

   - `ros::init(argc, argv, "chao_node");`：初始化一个名为`chao_node`的ROS节点。

9. 打印消息：

   - `printf("我的枪去而复返，你的生命有去无回!\n");`：在控制台打印一条消息，增加程序的趣味性。

10. 创建节点句柄：

    - `ros::NodeHandle nh;`：创建一个节点句柄，用于节点的通信。

11. 创建发布者：

    - `ros::Publisher pub = nh.advertise<std_msgs::String>("快上车开黑群", 10);`：创建一个发布者，发布到名为`快上车开黑群`的话题，消息类型为`std_msgs::String`，队列大小为10。

12. 设置循环频率：

    - `ros::Rate loop_rate(10);`：设置循环频率为10Hz，即每秒执行10次循环。

13. 消息循环：

    - `while (ros::ok())`：进入一个循环，只要ROS节点处于活动状态，循环就会继续。

14. 创建和发布消息：

    - `std_msgs::String msg;`：创建一个`std_msgs::String`类型的消息对象。
    - `msg.data = "国服马超，带飞";`：设置消息的内容。
    - `pub.publish(msg);`：通过发布者发布消息。

15. 控制循环频率：

    - `loop_rate.sleep();`：等待直到下一次循环开始，保持10Hz的频率。

16. 程序结束：

    - `return 0;`：程序正常结束。

![image-20241023225715185](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019922.png)



**4. 控制消息发布频率**

- 使用`ros::Rate`控制发布频率：

  ![image-20241023225225524](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019923.png)

  ```cpp
  ros::Rate loop_rate(10);
  while (ros::ok()) {
      // 发布消息
      pub.publish(msg);
      loop_rate.sleep();
  }
  ```



**5. 编译和运行节点**

- 确保代码保存后编译节点。

1.执行roscore，运行ROS核心。

![image-20241023224616802](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019924.png)

2.Ctrl+shift+o分屏，运行节点并检查输出。

![image-20241023224850937](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019925.png)



**6. 使用ROS命令行工具**

![image-20241023225811137](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019926.png)

- 使用`rostopic list`查看活跃话题。

  ![image-20241023224930203](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019927.png)

- 使用`rostopic echo [topic]`查看话题消息。

![image-20241023224950943](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019928.png)

会发现出现下面这种情况

![image-20241023225014284](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019929.png)

echo -e查看

![image-20241023225041329](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019930.png)

发现是这样的

- 使用`rostopic hz [topic]`查看消息发布频率。

![image-20241023225122890](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019931.png)

**7. 调试和验证**

- 检查消息类型和话题名称是否正确。
- 确保消息发布频率符合预期。

**8. 复制和修改节点**

- 复制现有节点代码以创建新节点。

![image-20241023225917602](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019932.png)

- 修改新节点的名称、话题名称和消息内容。

![image-20241023225944581](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019933.png)

![image-20241023230017788](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019934.png)

运行后检查

![image-20241023230202920](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019935.png)

**注意事项**

-  话题名称必须合法，不能使用中文。
-  包含正确的消息类型头文件。
-  使用`ros::Rate`对象控制消息发布频率。
-  利用ROS命令行工具进行调试和验证。



### 14. Subscriber订阅者的C++实现

**1. 创建新的ROS软件包**

如果无法自动补全，看这个链接

[vscode c++可以找到声明却无法自动补全-CSDN博客](https://blog.csdn.net/ccSnown/article/details/140300778?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Ctr-1-140300778-blog-104835613.235^v43^pc_blog_bottom_relevance_base1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Ctr-1-140300778-blog-104835613.235^v43^pc_blog_bottom_relevance_base1&utm_relevant_index=2)

软件包创建位置

![image-20241009183438243](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019936.png)

![image-20241009190032958](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019937.png)

缓存长度等信息：

![image-20241009192025502](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019938.png)

**定义回调函数**

在ROS（Robot Operating System）中，**定义回调函数**通常是指创建一个函数，该函数作为响应某个事件或消息到达时的处理器。这种模式在订阅话题（topic）时非常常见，当订阅者节点接收到新的消息时，ROS需要知道如何处理这条消息，这时就会用到回调函数。

```cpp
void 超下划线callback(const std_msgs::String::ConstPtr& msg) {
    printf("%s\n", msg->data.c_str());
}
```

![image-20241009192226114](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019939.png)

**回调函数的基本概念：**

1. **事件驱动**：回调函数是事件驱动编程的一部分。在这种编程模式中，程序的执行流程不是由程序本身控制，而是由外部事件（如用户输入、消息到达等）触发。
2. **非阻塞**：在ROS中，回调函数通常设计为非阻塞，这意味着它们执行完毕后会立即返回控制权，不会影响主程序的执行。
3. **异步处理**：回调函数允许程序异步处理消息，即在接收到消息时立即处理，而不是等待主程序在某个时间点去检查消息。

想象一下，你在一个餐厅里工作，你的工作是服务员。餐厅里有很多客人，你不能一直站在每个客人面前等着他们叫你，因为你还有其他工作要做。所以，你告诉每个客人，如果他们需要服务，就按一下桌上的服务铃。每次有客人按铃，你就去他们的桌子那里，看看他们需要什么服务。

在这个比喻中：

- 你就像是一个程序。
- 客人就像是一个等待消息的系统。
- 服务铃就像是一个触发回调函数的机制。
- 你听到铃声后去服务客人的动作，就像是回调函数被触发并执行。

所以，当你（程序）订阅了一个话题（等待客人按铃）并提供了一个回调函数（去客人桌子那里），你就告诉了系统（餐厅），如果有人（消息）来了，就执行这个特定的动作（回调函数）。这样，你（程序）就可以继续做其他事情（服务其他客人），直到铃声（新消息）响起。

回调函数的作用就是：

1. **自动化响应**：你不需要时刻检查每个客人是否需要服务，铃声会自动告诉你。
2. **节省时间**：你可以在有需要时立即响应，而不是浪费时间不断检查。
3. **专注于主要任务**：你可以继续做其他工作，直到有客人需要服务。
4. **响应速度快**：客人一按铃，你就能立刻去服务，提高了响应速度。



**2.编辑节点信息**

这段代码是一个ROS节点的C++实现，用于创建一个名为“ma_node”的节点，该节点订阅了一个名为“kuai_shang_che_kai_hei_qun”的话题，并定义了一个回调函数来处理接收到的消息。

![img](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019940.png)

这段代码是一个小机器人程序，它在ROS（机器人操作系统）的环境中运行。这个程序的作用是监听一个聊天群，当有人在群里发消息时，程序会读取这个消息并打印出来。

1. 程序一开始，它会告诉ROS系统，它是一个名为"ma_node"的节点。

2. 然后，它创建了一个订阅者，订阅了一个名为"kuai_shang_che_kai_hei_qun"的话题。这个话题就像是一个聊天群，其他机器人或程序可以在这个群里发消息。

3. 当有消息发到这个群时，程序会调用一个名为`chao_callback`的函数来处理这个消息。这个函数会读取消息内容，并在控制台上打印出来。

4. 程序会一直运行，直到ROS节点被关闭。在这个过程中，它会不断地检查是否有新的消息到达，并及时处理。

       #include <ros/ros.h>
       #include <std_msgs/String.h>
       
       // 定义回调函数
       void chao_callback(const std_msgs::String::ConstPtr& msg)
       {
           // 打印接收到的消息
           printf("%s\n", msg->data.c_str());
       }
       
       int main(int argc, char* argv[])
       {
           // 初始化ROS节点，节点名为"ma_node"
           ros::init(argc, argv, "ma_node");
           
       // 创建节点句柄
       ros::NodeHandle nh;
       
       // 创建一个Subscriber，订阅"kuai_shang_che_kai_hei_qun"话题，消息类型为std_msgs::String，队列大小为10，回调函数为chao_callback
       ros::Subscriber sub = nh.subscribe("kuai_shang_che_kai_hei_qun", 10, chao_callback);
       
       // 进入循环，直到ROS节点关闭
       while (ros::ok())
       {
           // 调用ros::spinOnce()来处理回调函数
           ros::spinOnce();
       }
       
       // 返回0，表示程序正常结束
       return 0;
       }

   1. `#include <ros/ros.h>` 和 `#include <std_msgs/String.h>`：

      - 这两行代码包含了必要的头文件，`ros/ros.h` 是ROS的核心头文件，提供了基本的ROS功能。`std_msgs/String.h` 是标准字符串消息类型的头文件，它定义了一种简单的字符串消息格式。

   2. `void chao_callback(const std_msgs::String::ConstPtr& msg)`：

      - 这是一个回调函数，当订阅的话题有新消息到达时，这个函数会被调用。
      - `const std_msgs::String::ConstPtr& msg` 是传递给回调函数的消息对象，它包含了消息的内容。

   3. `printf("%s\n", msg->data.c_str());`：

      - 这行代码将消息内容打印到控制台。`msg->data.c_str()` 获取消息中的字符串数据。

   4. `int main(int argc, char* argv[])`：

      - 这是程序的主函数入口点，接收命令行参数。

   5. `ros::init(argc, argv, "ma_node");`：

      - 这行代码初始化了一个名为“ma_node”的ROS节点。

   6. `ros::NodeHandle nh;`：

      - 创建了一个节点句柄，它用于创建发布者（publisher）和订阅者（subscriber），以及访问ROS参数服务器。

   7. `ros::Subscriber sub = nh.subscribe("kuai_shang_che_kai_hei_qun", 10, chao_callback);`：

      - 这行代码创建了一个订阅者，它订阅了名为“kuai_shang_che_kai_hei_qun”的话题，消息类型为`std_msgs::String`，队列大小为10，回调函数为`chao_callback`。

   8. `while (ros::ok())`：

      - 这是一个循环，它将持续运行直到ROS节点被关闭。

   9. `ros::spinOnce();`：

      - 这行代码告诉ROS在这个节点中处理一次回调。通常，这会在一个循环中调用，以确保程序能够及时响应新的消息。

   10. `return 0;`：

       - 这表示程序正常结束。

       还需要再做一些修改，如下所示

       ![image-20241023234651828](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019941.png)

5. **设置程序的locale为中文**：这行代码`setlocale(LC_ALL, "zh_CN.UTF-8");`是为了让程序能够正确显示中文字符。就像是告诉电脑：“嘿，我要用中文了，你准备好显示中文哦。”

6. **初始化ROS节点**：`ros::init(argc, argv, "ma_node");`这行代码是告诉ROS系统，你要开始一个新的节点，这个节点的名字叫“ma_node”。节点就像是ROS世界中的一个小程序或者任务。

7. **创建节点句柄**：`ros::NodeHandle nh;`节点句柄就像是控制节点的遥控器，通过它，你的节点可以和其他节点交流。

8. **创建订阅者**：通过`ros::Subscriber sub = nh.subscribe("kuai_shang_che_kai_hei_qun", 10, chao_callback);`这行代码，你的节点开始监听一个特定的话题“kuai_shang_che_kai_hei_qun”。每当这个话题有新消息时，就会调用`chao_callback`这个函数来处理消息。

9. **进入循环**：`while (ros::ok())`这个循环会一直运行，直到ROS系统告诉你可以停止了。在这个循环里，`ros::spinOnce();`会检查是否有新的消息到来，如果有，就处理它们。

   #include <ros/ros.h>
   #include <std_msgs/String.h>
   #include <locale.h> // 包含setlocale函数的头文件

   // 定义回调函数
   void chao_callback(const std_msgs::String::ConstPtr& msg)
   {
       // 使用ROS_INFO宏打印消息内容
       ROS_INFO("%s", msg->data.c_str());
   }

   int main(int argc, char* argv[])
   {
       // 设置程序的locale为中文，以便正确显示中文字符
       setlocale(LC_ALL, "zh_CN.UTF-8");
       
   // 初始化ROS节点，节点名为"ma_node"
   ros::init(argc, argv, "ma_node");

   // 创建节点句柄
   ros::NodeHandle nh;

   // 创建一个Subscriber，订阅"kuai_shang_che_kai_hei_qun"话题，消息类型为std_msgs::String，队列大小为10，回调函数为chao_callback
   ros::Subscriber sub = nh.subscribe("kuai_shang_che_kai_hei_qun", 10, chao_callback);

   // 进入循环，直到ROS节点关闭
   while (ros::ok())
   {
       // 调用ros::spinOnce()来处理回调函数
       ros::spinOnce();
       // 休眠一小段时间，避免CPU占用过高
       ros::Duration(0.01).sleep();
   }

   // 返回0，表示程序正常结束
   return 0;
   }

10. **设置locale**：`setlocale(LC_ALL, "zh_CN.UTF-8");`用于设置程序的区域设置为中文环境，确保程序在输出日志或者错误信息时能够正确处理和显示中文字符。

11. **节点初始化**：`ros::init(argc, argv, "ma_node");`初始化一个名为"ma_node"的ROS节点。这是ROS程序的标准实践，其中`argc`和`argv`是从命令行传递给程序的参数。

12. **节点句柄**：`ros::NodeHandle nh;`创建一个节点句柄对象，它是操作ROS节点的接口，用于订阅话题、发布消息、设置参数等。

13. **订阅话题**：`ros::Subscriber sub = nh.subscribe("kuai_shang_che_kai_hei_qun", 10, chao_callback);`创建一个订阅者对象，订阅名为"kuai_shang_che_kai_hei_qun"的话题。当有消息发布到这个话题时，`chao_callback`函数会被调用。参数`10`指定了消息队列的最大长度。

14. **事件循环**：`while (ros::ok())`是一个事件循环，它保持程序运行并响应ROS系统的消息。`ros::spinOnce();`告诉ROS在这个节点中处理一次回调，而`ros::Duration(0.01).sleep();`则是为了避免程序占用过多的CPU资源，在处理完一次回调后进行短暂的休眠。

写完之后就会有时间戳，而且也不会输出乱码

![image-20241023234858592](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019942.png)

加上yao_的节点和消息类型

![image-20241023235209273](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019943.png)

运行发布者yao节点

![image-20241023235306388](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019944.png)

运行订阅者ma节点

![image-20241023235439937](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019945.png)

**总结**

![image-20241023235949450](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019946.png)



**3. 编译和运行订阅者节点**

- 更新`CMakeLists.txt`，添加编译规则。

  ![image-20241023232945711](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019947.png)

  ![image-20241023233005458](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019948.png)

  复制上方内容到最后，修改为如下所示

  ![image-20241023233217880](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019949.png)

- 使用`catkin_make`编译。Ctrl+S保存，Ctrl+shift+B编译

- Ctrl+alt+T启动终端，运行ROS核心：`roscore`

![image-20241023233317605](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019950.png)

- 运行订阅者节点：

  ![image-20241023233522239](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019951.png)

**4. 调试和验证**

- 使用`rostopic list`查看活跃话题。
- 使用`rostopic echo [topic]`查看特定话题的消息。
- 使用`rostopic hz [topic]`查看消息频率。

**5. 处理多个话题订阅**

![image-20241023235540297](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019952.png)

- 为每个话题创建`Subscriber`对象。
- 为每个话题定义相应的回调函数。

**6. 使用ROS工具`rqt_graph`**

![image-20241024000015804](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019953.png)

![image-20241023235601003](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019955.png)

- 显示当前系统中节点和话题的通讯关系。

  ![image-20241023235624817](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019956.png)

  椭圆的是节点，矩形的是话题

- 帮助理解数据流向和处理流程。

![image-20241023235717719](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019957.png)

**7. 话题的生命周期**

- 话题由ROS系统创建管理。
- 节点通过发布或订阅操作触发话题的创建。

**注意事项**

- 确保话题名称和消息类型正确。
- 回调函数中处理接收到的消息。
- 使用`ros::spin()`或`ros::spinOnce()`在主循环中处理消息。



### 15. launch启动多个ROS节点

**1. 什么是Launch文件**

- Launch文件是一种遵循XML语法的描述文件，用于批量启动ROS节点。
- 它简化了多个节点的启动过程。

![image-20241024115056265](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019958.png)

![image-20241024115259251](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019959.png)

![image-20241024115358976](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019960.png)

**2. 创建Launch文件**

- 在任意软件包内创建`launch`目录。

![image-20241024115518287](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019961.png)

- 在`launch`目录内创建Launch文件，如`kai_hei.launch`。

**3. 编写Launch文件内容**

- 使用XML语法描述要启动的节点。

![image-20241024115823514](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019962.png)

这个文件就像是一个控制面板，它允许你一次性启动多个ROS节点。每个节点就像是ROS系统中的一个小程序，它们可以执行特定的任务，比如发送消息、接收消息或者控制机器人。

1. `<launch>`标签定义了这个文件是一个ROS的启动文件。

2. ```
   <node>
   ```

   标签用于启动一个节点。在这个文件中，有三个节点被启动：

   - `yao_node`：这是第一个节点，它属于`ssr_pkg`包。
   - `chao_node`：这是第二个节点，它也属于`ssr_pkg`包。
   - `ma_node`：这是第三个节点，它属于`atr_pkg`包。

3. `pkg`属性指定了节点所属的ROS包。

4. `type`属性指定了节点的可执行文件类型。

5. `name`属性为节点指定了一个名称。

6. `output="screen"`属性确保节点的输出会显示在屏幕上，这样你就可以看到节点的运行情况。这个属性是一个可选的参数，它将节点的标准输出和标准错误重定向到屏幕，方便开发者调试和监控节点的运行状态。

当你运行这个启动文件时，ROS会根据这个文件中的指令启动所有指定的节点。

- 示例：

  ```xml
  <launch>
      <!-- 启动名为yao_node的节点，它属于ssr_pkg包 -->
      <node pkg="ssr_pkg" type="yao_node" name="yao_node" output="screen"/>
      <!-- 启动名为chao_node的节点，它也属于ssr_pkg包 -->
      <node pkg="ssr_pkg" type="chao_node" name="chao_node" output="screen"/>
      <!-- 启动名为ma_node的节点，它属于atr_pkg包 -->
      <node pkg="atr_pkg" type="ma_node" name="ma_node" output="screen"/>
  </launch>
  ```

使用启动文件的好处是，你可以集中管理节点的启动参数，并且可以轻松地修改这些参数，而不需要修改节点的代码。此外，启动文件也使得节点的启动过程更加模块化和可重用。

**4. 启动Launch文件**

- 使用`roslaunch`命令启动：

  ```
  roslaunch [package_name] [launch_file_name]
  ```

- 例如：

  ![image-20241024120214542](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019963.png)

  ```
  roslaunch atr_pkg kai_hei.launch
  ```

在ROS中，`roslaunch`是一个用于启动节点的高级工具，它允许用户通过一个XML格式的`.launch`文件来启动一个或多个节点。这种方式可以简化节点的启动过程，特别是当需要同时启动多个节点时。

1. `roslaunch`：这是执行命令的ROS工具，用于解析`.launch`文件并启动其中定义的节点。
2. `atr_pkg`：这是ROS包的名称，该包中包含了要启动的节点。
3. `kai_hei.launch`：这是`.launch`文件的名称，它位于`atr_pkg`包的`launch`目录下。这个文件定义了要启动的节点及其参数。

当执行这个命令时，`roslaunch`会读取`kai_hei.launch`文件，解析其中的XML内容，并根据这些内容启动节点。这些节点可以是任何可执行文件，包括发布者、订阅者、服务服务器、服务客户端等。

**5. 设置节点输出**

- 使用`output`属性控制节点输出到屏幕或独立终端。
- `output="screen"`：输出到当前终端。
- `launch_prefix="non_terminal"`：在新终端中运行节点。

![image-20241024120528843](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019964.png)

在上述内容后面加入一下代码，补全后的代码可能如下：

<launch>
    <!-- 使用output="screen"将节点输出到当前终端 -->
    <node pkg="ssr_pkg" type="yao_node" name="yao_node" output="screen"/>
    <!-- 使用launch-prefix为节点创建一个新的终端窗口 -->
    <node pkg="ssr_pkg" type="chao_node" name="chao_node" launch-prefix="gnome-terminal --">
        <!-- 设置终端窗口标题 -->
        <arg>--name</arg>
        <arg>chao_node</arg>
    </node>
    <!-- 输出ma_node节点信息到当前终端 -->
    <node pkg="atr_pkg" type="ma_node" name="ma_node" output="screen"/>
</launch>

1. `output="screen"`：这个指令告诉ROS，当节点运行时，它的输出（比如打印的信息）应该显示在当前的终端屏幕上。
2. `launch-prefix="gnome-terminal --"`：这个指令告诉ROS，当启动名为`chao_node`的节点时，应该先打开一个新的终端窗口（在这里使用的是`gnome-terminal`，这是一个Linux系统中的终端模拟器），然后在新窗口中运行这个节点。这样做的好处是，你可以在不同的窗口中运行不同的节点，方便查看和管理。
3. `<arg>--name</arg><arg>chao_node</arg>`：这两行代码为`gnome-terminal`提供了额外的参数，设置新终端窗口的标题为`chao_node`。

此时会单独给超的节点开一个窗口

![image-20241024120637706](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019965.png)

节点网络中也没有chao的话题

![image-20241024120720933](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019966.png)

**6. 使用rqt_graph工具**

- 使用`rqt_graph`可视化节点和话题的通讯关系。

![image-20241024120354384](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019967.png)

**7. 节点调试**

- 将节点配置为在独立终端中运行，便于调试和观察输出。

**8. 理解Launch文件的重要性**

- Launch文件是软件包的重要入口，有助于理解软件包的功能和结构。

**注意事项**

- 确保Launch文件的语法正确。
- 合理使用`output`和`launch_prefix`属性，便于节点管理和调试。

![image-20241024120817161](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019968.png)



### 16. Publisher发布者的Python实现

**1. 创建ROS软件包**

- 包名：`SSR_package`
- 依赖项：`std_msgs`
- 终端命令：`cd ~/catkin_ws/src && catkin_create_package SSR_package std_msgs`

![image-20241024121310696](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019969.png)

回退后编译

![image-20241024121507431](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019970.png)

1. **创建ROS包**：
   - `catkin_create_pkg ssr_pkg rospy std_msgs`：这个命令创建了一个名为`ssr_pkg`的新ROS包，并指定了它依赖的两个ROS包：`rospy`和`std_msgs`。`rospy`是ROS的Python接口，`std_msgs`是ROS的标准消息类型包。
   - 这个命令会在当前目录（`~/catkin_ws/src`）下创建一个新的文件夹`ssr_pkg`，并在其中生成必要的文件，如`package.xml`和`CMakeLists.txt`，以及一个`src`文件夹。
2. **切换目录**：
   - `cd ..`：这个命令将当前目录切换到上一级目录，即从`~/catkin_ws/src`切换到`~/catkin_ws`。
3. **编译ROS工作空间**：
   - `catkin_make`：这个命令用于编译整个ROS工作空间（`catkin_ws`）。它会查找所有ROS包的源代码，根据`CMakeLists.txt`文件中的指令进行编译，并生成可执行文件和库文件。这步的编译是为了让软件包进入ros的编译节点（新建好软件包后执行一次就可以）

**2. 创建Python节点脚本**

- 在`SSR_package`包内创建`scripts`目录。
- 在`scripts`目录内创建Python脚本，如`chao_node.py`。

![image-20241024122454144](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019971.png)

**3. 编写Python节点代码**

- 指定Python解释器和编码：

  ```python
  #!/usr/bin/env python3
  # -*- coding: utf-8 -*-
  ```

- 引入ROS库和消息类型：

  ```python
  import rospy
  from std_msgs.msg import String
  ```

- 实现节点功能：

  ```python
  def talker():
      pub = rospy.Publisher('topic_name', String, queue_size=10)
      rate = rospy.Rate(10)  # 10hz
      while not rospy.is_shutdown():
          msg = String()
          msg.data = 'Message content'
          pub.publish(msg)
          rate.sleep()
  ```

- 主函数：

  ```python
  if __name__ == '__main__':
      rospy.init_node('node_name', anonymous=True)
      print("Node initialized.")
      talker()
  ```



![image-20241024122645550](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019972.png)

从Nodehandle变成rospy

![image-20241024122948432](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019973.png)

**4. 赋予脚本执行权限**

![image-20241024123519029](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019974.png)

![image-20241024123920252](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019975.png)

终端命令：在Linux或类Unix系统的终端中使用的，用于修改文件权限。

robot@WP:~/catkin_ws/src/ssr_pkg/scripts$     chmod +x chao_node.py

![img](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019976.png)

1. 文件权限修改：
   - `chmod`是Linux系统中用于改变文件或目录权限的命令。
   - `+x`参数指定了增加执行权限。在Linux系统中，文件权限通常分为读（r）、写（w）和执行（x）。
2. ROS脚本：
   - `chao_node.py`很可能是一个Python脚本，它定义了一个ROS节点。在ROS中，节点是基本的执行单元，可以发布消息、订阅话题或提供服务。
3. 执行脚本：
   - 在给予脚本执行权限后，用户可以在该脚本所在的目录下通过命令`./chao_node.py`来运行这个节点。
   - 如果脚本是作为一个ROS节点编写的，它通常会使用`rospy`库来与ROS通信。
4. 目录结构：
   - 该命令在`~/catkin_ws/src/ssr_pkg/scripts`目录下执行，这是ROS包结构中用于存放可执行脚本的标准位置。

通过这些步骤，你可以确保你的Python脚本在ROS环境中可以被执行，从而作为节点参与到ROS的消息传递和任务处理中。这是ROS开发中常见的操作，用于部署和运行自定义的节点。



**5. 运行Python节点**

- 启动ROS核心：`roscore`

![image-20241024125205319](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019977.png)

- 运行节点：`rosrun SSR_package 超哥节点.py`

![image-20241024125258371](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019978.png)

**6. 验证节点运行**

- 查看活跃话题：`rostopic list`

![image-20241024125314812](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019979.png)

- 查看话题消息：`rostopic echo /topic_name`

![image-20241024125333299](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019980.png)

![image-20241024125352571](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019981.png)

**7. 复制和修改节点**

- 复制现有Python脚本并修改内容以创建新节点。

![image-20241024125421143](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019982.png)

- 修改节点名称、话题名称和消息内容。

![image-20241024125538179](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019983.png)

这个Python脚本就像是一个自动发消息的机器人。它在ROS系统中运行，不断地向一个叫做“gie_gie_dai_wo”的话题发送消息。这个消息的内容是“求上车+++”。

1. 脚本一开始，它会告诉ROS系统，它是一个名为“yao_node”的节点。
2. 然后，它会创建一个“发布者”（Publisher），这个发布者负责向“gie_gie_dai_wo”话题发送消息。
3. 接着，它进入一个循环，不断地发送消息。每10秒钟，它就会发送一次消息，并且每次发送前都会在控制台打印“我要开始刷屏了”。
4. 消息的内容是“求上车+++”，这就像是机器人在不断地告诉别人：“快上车，跟我一起走！”

**注意事项**

- Python节点不需要编译，可直接运行。
- 确保Python脚本具有执行权限。
- 使用`rosrun`运行Python节点。
- 使用`rostopic`工具验证节点发布的消息。



### 17. Subscriber订阅者的Python实现

**1. 创建ROS软件包**

让新建的软件包进入执行列表（在RO环境中创建一个新的ROS包并编译它）

这个过程是在ROS环境中创建一个新的ROS包并编译它的步骤，这是开始一个新的ROS项目的基础步骤，为后续的开发工作打下基础。通过这些命令，你可以初始化一个新的ROS包结构，生成必要的配置文件，并准备包的源代码目录，最后通过编译整个工作空间来确保新包被正确构建。

![image-20241024130536556](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019984.png)

1. 进入工作空间的源代码目录：

   - 首先，通过`cd ~/catkin_ws/src/`命令，我们进入了ROS工作空间的`src`目录，这是创建新包的地方。

2. 创建新的ROS包：

   - 使用`catkin_create_pkg atr_pkg rospy std_msgs`命令创建了一个新的ROS包，名字叫`atr_pkg`。这个命令还告诉我们，它为我们生成了一些重要的文件和文件夹，比如`package.xml`和`CMakeLists.txt`，以及一个`src`文件夹。

3. 返回到工作空间目录：

   - 通过`cd ..`命令，我们返回到了`catkin_ws`目录。

4. 编译ROS工作空间：

   - 最后，使用`catkin_make`命令来编译整个工作空间，这会包括我们刚刚创建的新包`atr_pkg`。

   ```
   cd ~/catkin_ws/src/
   catkin_create_pkg atr_pkg rospy std_msgs
   cd ..
   catkin_make
   ```

   **2. 创建Python节点脚本**

- 在`atr_package`包内创建`scripts`目录。
- 在`scripts`目录内创建Python脚本，如`ma_note.py`。

![image-20241024131056962](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019986.png)

![image-20241024131534618](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019987.png)

![image-20241024131657611](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019988.png)

**3. 编写Python节点代码**

![img](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019989.png)



```
#!/usr/bin/env python3
# coding=utf-8

import rospy
from std_msgs.msg import String

def chao_callback(msg):
    rospy.loginfo(msg.data)

if __name__ == "__main__":
    rospy.init_node("ma_node")
    sub = rospy.Subscriber("kuai_shang_che_kai_hei_qun", String, chao_callback, queue_size=10)
    rospy.spin()
```

**4. 赋予脚本执行权限**

![image-20241024164127153](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019990.png)

![image-20241024164136543](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019991.png)

- 终端命令：`chmod +x ma_note.py`

![image-20241024164154940](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019992.png)

没有报错，说明运行成功了

**5. 运行Python节点**

- 启动ROS核心：`roscore`

![image-20241024164250304](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019993.png)

- 运行发布者节点：

![image-20241024164307161](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019994.png)

运行接受者节点：

![image-20241024164335631](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019995.png)

![image-20241024164442520](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019996.png)

在ROS系统中，这段代码涉及到两个主要的概念：发布者（publisher）和订阅者（subscriber）。

1. **发布者**：发布者就像是一个广播站，它会定期发送消息。在这个例子中，消息是“国服马超，带飞”。
2. **订阅者**：订阅者就像是一个收音机，它会监听广播站发出的消息。当它收到消息时，它会记录下来或者做出反应。

**发布消息的代码（Publisher）**

```python
rospy.loginfo("我要开始刷屏了")
msg = String()
msg.data = "国服马超，带飞"
pub.publish(msg)
pub.publish(msg)
rate.sleep()
```

1. `rospy.loginfo("我要开始刷屏了")`：这行代码使用ROS的日志系统输出一条信息，告诉用户程序即将开始发送消息。
2. `msg = String()`：这里创建了一个名为`msg`的变量，它是一个`String`类型的消息对象。
3. `msg.data = "国服马超，带飞"`：这行代码设置`msg`对象的`data`属性，即消息的内容，这里设置为“国服马超，带飞”。
4. `pub.publish(msg)`：这行代码将`msg`对象发布到一个话题上。任何订阅了这个话题的节点都可以接收到这条消息。这里连续调用了两次`pub.publish(msg)`，意味着会发送两次消息。
5. `rate.sleep()`：这行代码让当前线程休眠一段时间。通常，这行代码会与一个`rospy.Rate`对象一起使用，以控制消息发送的频率。例如，`rate = rospy.Rate(1)`表示每秒发送一次消息。

**接收消息的代码（Subscriber）**

```python
def chao_callback(msg):
    rospy.loginfo(msg.data)
```

1. `def chao_callback(msg):`：这行代码定义了一个名为`chao_callback`的函数，它是一个回调函数。当订阅的话题有新消息时，这个函数会被调用。
2. `rospy.loginfo(msg.data)`：在回调函数内部，使用ROS的日志系统输出接收到的消息内容。`msg.data`是接收到的消息对象的`data`属性，即消息的内容。

![image-20241024164554826](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019997.png)

![image-20241024164615409](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019998.png)

**6. 查看节点运行**

- 查看活跃话题：`rostopic list`
- 查看话题消息：`rostopic echo /topic_name`

**7. 创建Launch文件**

- 在`atr_package`包内创建`launch`目录。

- 在`launch`目录内创建Launch文件，如`kai_hei.launch`。

![image-20241024165618375](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019999.png)

- 编写Launch文件内容：

  ![image-20241024165731896](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019000.png)

  它告诉机器人在开始工作前需要启动哪些程序。每个程序都是一个独立的任务，比如发送消息、接收消息或者执行其他任务。

  ```xml
  <launch>
      <node pkg="ssr_pkg" type="chao_node.py" name="chao_node"/>
      <node pkg="ssr_pkg" type="yao_node.py" name="yao_node"/>
      <node pkg="atr_pkg" type="ma_node.py" name="ma_node" launch-prefix="gnome-terminal --"/>
  </launch>
  ```

在ROS中，启动文件（launch files）用于定义一组节点的启动配置。这些节点可以是单独的程序，也可以是脚本，它们在ROS系统中执行特定的任务。通过`<node>`标签，我们可以指定要启动的节点的包名、类型、名称以及启动前缀。

- `pkg`属性指定了节点所属的ROS包。
- `type`属性指定了节点的可执行文件名。
- `name`属性为节点提供了一个在ROS中的唯一标识。
- `launch-prefix`属性允许我们在启动节点之前执行特定的命令，这在调试时非常有用，因为它可以在新的终端窗口中启动节点，使得输出更加清晰。

**8. 运行Launch文件**

- 启动所有节点：`roslaunch a_tr_package 开黑.launch`

![image-20241024165757011](https://raw.githubusercontent.com/dhw2536/Picture/main/202411110019001.png)

**注意事项**

- Python节点不需要编译，可直接运行。
- 确保Python脚本具有执行权限。
- 使用`rosrun`运行Python节点。
- 使用`roslaunch`启动Launch文件。
